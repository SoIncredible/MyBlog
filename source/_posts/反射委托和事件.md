---
title: 反射委托和事件
tags:
  - C#
categories: 学习笔记
abbrlink: cd96d12
date: 2023-03-17 15:48:00
cover: "http://soincredible777.com.cn:90/25.png"
description:
swiper_index:
sticky:
---

# 背景

这篇博客本来想聊一聊反射的内容，但是反射的前置知识点优点太多了，所以真正要聊到反射可能要到下一篇博客了。

# 重写、重载、多态的区别

重写 `override` 重载 `overload` 多态`polymorphism`

重写`override`指的是重写了一个方法来实现不同的功能，一般是用于子类在继承父类的时候后，重写父类中的方法，重写的规则：

1. 重写方法的参数列表必须完全与被重写方法的参数列表相同，否则就不能称之为重写而是重载
2. 重写方法的访问修饰符一定要大于被重写方法的访问修饰符public > protected > default > private
3. 重写的方法的返回值必须和被重写方法的返回值一致
4. 重写的方法所抛出的异常必须和被重写方法所抛出的异常一致，或者是其子类
5. 被重写的方法不能是private，否则在其子类中只是新定义了一个方法，并没有对其进行重写
6. 静态方法不能被重写为非静态方法
7. 静态方法属于类，不能被重写，因此也不能多态

重载`overload`一般用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同

重载的规则：

1. 在使用重载时只能通过相同的方法名、不同的参数形式实现。可以是不同的参数个数，不同的参数顺序（参数类型必须不一样）
2. 不能通过访问权限、返回类型、抛出的异常进行重载
3. 方法的异常类型和数目不会对重载造成影响

多态`polymorphism`可以是静态的或动态的，在静态多态性中，函数的响应是在编译的时候发生的。在动态多态性中，函数的响应是在运行时发生的。

静态多态：在编译阶段，函数和对象的连接机制被称为早起绑定，也被称为静态绑定。C#提供了两种技术来实现静态多态性：函数重载和[运算符重载](#2)

动态多态的三个条件：

1. 继承
2. 重写（重写父类继承的方法）
3. 父类引用指向子类的对象（这个在[IEnumerator和IEnumerable的理解与辨析](http://soincredible777.com.cn/posts/133a9667/)这篇博客末尾提到了，当时还不太明确这是实现多态的一个条件），语句在堆内存中开辟了子类的对象，并把栈内存中的父类的引用指向了这个子类的对象

## 函数重载实例

我们可以在同一个范围内对相同的函数名有多个定义，函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。**不能重载只有返回类型不同的函数声明**

```C#
namespace LearnOverload
{
    public class Overload
    {
        public static int Add(int a, int b, int c)
        {
            return a + b + c;
        }

        public static int Add(int a, int b)
        {
            return a + b;
        }
      
      	public static float Add(float a, float b)
        {
            return a + b;
        }

        static void Main(string[] args)
        {
            int a = 1;
            int b = 1;
            int c = 1;
            Console.WriteLine(Overload.Add(a, b));
            Console.WriteLine(Overload.Add(a, b, c));
        }
    }
}
```

## 动态多态：

C#允许我们使用关键字`abstract`创建抽象类，用于提供接口部分类的实现。当一个派生类继承自该抽象类时，实现即完成。抽象类包含抽象方法，抽象方法可以被派生类实现，派生类具有更专业的功能，我们在使用抽象类的时候要注意以下几点：

- 我们不能创建一个抽象类的实例
- 我们不能在一个抽象类外部声明一个抽象方法
- 通过在类定义前面放置关键字`sealed`，可以将类声明为密封类。当一个类被声明为`sealed`时，它不能被继承。抽象类不能被声明为`sealed`

```C#
namespace PolymorhismApplication
{
    public abstract class Shape
    {
        public abstract int Area();
    }

    class Rectangle : Shape
    {
        private int _length;
        private int _width;

        public Rectangle(int a, int b)
        {
            _length = a;
            _width = b;
        }

        public int Length
        {
            set { _length = value; }
            get { return _length; }
        }

        public int Width
        {
            set { _width = value; }
            get { return _width; }
        }


        public override int Area()
        {
            return _length * _width;
        }
    }

    class RectangleTest
    {
        static void Main(string[] args)
        {
            Rectangle r = new Rectangle(2, 3);
            Console.WriteLine(r.Area());
            Console.ReadKey();
        }
    }
}
```

下面使用了虚方法来实现多态

```C#
namespace PolymorhismApplication
{
    public class Shape
    {
        public virtual int? Area()
        {
            Console.WriteLine("执行了绘制图形的基类");
            return null;
        }
    }

    class Rectangle : Shape
    {
        private int _length;
        private int _width;

        public Rectangle(int a, int b)
        {
            _length = a;
            _width = b;
        }

        public int Length
        {
            set { _length = value; }
            get { return _length; }
        }

        public int Width
        {
            set { _width = value; }
            get { return _width; }
        }


        public override int? Area()
        {
            Console.WriteLine("执行绘制矩形的函数");
            return _length * _width;
        }
    }


    class Circle : Shape
    {
        private int _radius;


        public int Radius
        {
            set { _radius = value; }
            get { return _radius; }
        }


        public Circle(int radius)
        {
            _radius = radius;
        }

        public override int? Area()
        {
            Console.WriteLine("执行Circle类的绘制函数");
            return null;
            return base.Area();
        }
    }

    class Test
    {
        static void Main(string[] args)
        {
            var shapes = new List<Shape>
            {
                new Rectangle(2, 3),
                new Circle(2)
            };

            foreach (var p in shapes)
            {
                p.Area();
            }

            Console.ReadKey();
        }
    }
}
```

联想：在写枚举器那一篇博客的时候，我们自己写枚举器的目的是为了枚举自己自定义的数据类型，而C#中是有List这个数据类型的，我们可以把我们自定义的数据类型放在List里，不也能实现枚举的效果么，那我们自己写枚举器的意义何在呢？

```C#
using System.Collections;

namespace learnIEnumerator
{
    public class Person
    {
        public string Name { set; get; }

        public Person(string name)
        {
            Name = name;
        }

        public void ShowName()
        {
            Console.WriteLine(Name);
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            var ll = new List<Person>
                {
                    new Person("李磊"),
                    new Person("王刚"),
                    new Person("彤彤"),
                    new Person("丹丹"),
                }
                ;
            foreach (Person p in ll)
            {
                Console.WriteLine(p.Name);
            }
        }
    }
}
```

## <span id = "2">运算符重载</span>

我们可以重定义或者重载C#中内置的运算符。因此，我们也可以使用自定义类型的运算符。重载运算符具有特殊名称的函数，是通过关键字`operator`后跟运算符的符号来定义的。于其他函数一样，重载运算符返回类型和参数列表：

```C#
namespace OverloadOperator
{
    public class Box
    {
        private double length;
        private double breadth;
        private double height;

        public double getVolume()
        {
            return length * breadth * height;
        }

        public void setBreadth(double bre)
        {
            breadth = bre;
        }

        public void setLength(double len)
        {
            length = len;
        }

        public void setHeight(double hei)
        {
            height = hei;
        }


        public static Box operator +(Box b, Box c)
        {
            Box box = new Box();
            box.length = b.length + c.length;
            box.breadth = b.breadth + c.breadth;
            box.height = b.height + c.height;
            return box;
        }
    }

    class Tester
    {
        static void Main(string[] args)
        {
            Box Box1 = new Box();
            Box Box2 = new Box();
            Box Box3 = new Box();
            double volume = 0.0;


            Box1.setLength(6.0);
            Box1.setBreadth(7.0);
            Box1.setHeight(5.0);

            Box2.setLength(12.0);
            Box2.setBreadth(13.0);
            Box2.setHeight(10.0);

            volume = Box1.getVolume();
            Console.WriteLine("Box1的体积：{0}", volume);

            volume = Box2.getVolume();
            Console.WriteLine("Box2的体积：{0}", volume);

            Box3 = Box1 + Box2;

            volume = Box3.getVolume();
            Console.WriteLine("Box3的体积：{0}", volume);
            Console.ReadKey();
        }
    }
}
```

上面的代码实现的是我们自己对自定义类Box的加法运算符，它把两个Box对象的属性相加，并返回相加后的Box对象。





# 特性

特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等等）的行为信息的声明性标签。我们可以使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号`[]`来描述的。

特性用于添加元数据，如编译器指令和注释

# 反射

反射指程序可以访问、检测和修改它本身状态和行为的一种能力。程序集包含模块，而模块包含类型，类型又包含成员。反射提供了封装程序集、模块和类型的对象。我们可以使用反射动态地创建类型的实例，将类型绑定到现有对象上，或者从现有对象中获取类型。然后可以调用类型的方法或者访问其字段和属性。

## 优缺点

优点：

1. 反射提高了程序的灵活性和扩展性
2. 降低耦合性，提高自适应能力
3. 它允许程序创建和控制任何类的对象，无需提前硬编码目标类

缺点：

1. 性能问题：反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码，因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。
2. 使用反射会模糊程序内部的逻辑，程序员希望在源码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更为复杂。

## 反射的用途：

反射有以下用途：

1. 它允许在运行时查看特性（attribute）信息
2. 它允许审查集合中的各种类型，以及实例化这些类型
3. 它允许延迟绑定的方法和属性
4. 它允许在运行时创建新的类型，然后使用这些类型执行一些任务









# 委托

一篇很好的博客https://www.cnblogs.com/skysoot/archive/2012/04/05/2433639.html

C#中的委托类似于C或C++中的函数指针。委托是存有对某个方法的引用的一种引用类型变量，引用可在运行时被改变。

委托特别用于实现事件和回调方法。所有的委托都派生自`System.Delegate`类。

## 从实际问题出发来理解委托

### 将方法作为方法的参数

这个标题非常地拗口，但我们先不管它，来看两个方法：

```C#
public void GreetPeople(string name){
	EnglishGreeting(name);
}
public void EnglishGreeting(string name){
  Console.WriteLine("Good Moring," + name);
}
```

先不管这两个方法有没有实际的意义，我们现在想通过这两个方法来向某人问好，当传入某人的姓名时，比如说"Joe"进去的时候，在这个方法中将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting方法则用于向屏幕输出"Good Moring, Joe"。

那么现在，假设这个程序要进行全球化了，我作为一个中国人，我不理解"Good Moring"是什么意思，那我就只能再加一个中文的问候方法：

```C#
public void ChineseGreeting(string name){
	Console.WriteLine("早上好，"+name);
}
```

这时候GreetPeople也需要改一下了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？当然在进行这个之前，我们最好再定义一个枚举作为判断的依据：

```C#
public enum Language{
	English, Chinese
}
public void GreetPeople(string name, Language lang){
	switch(lang){
		case Language.English:
			EnglishGreeting(name);
			break;
    case Language.Chinese:
    	ChineseGreeting(name);
    	break;	
	}
}
```

OK，尽管这样解决了问题，但是这个方法的可扩展性太差了，如果之后我们还要再添加韩文版、日文版，我们就不得不反复修改枚举和GreetPeople的方法，来适应新的需求。

那么在考虑新的解决方案之前，我们先来看看GreetPeople的方法签名：

```C#
public void GreetPeople(string name, Language lang);
```

我们只看`string name`，在这里，string是参数类型，name是参数变量，当我们赋给name字符串"Joe"时，他就代表了"Joe"这个值；当我们赋给他"周杰伦"时，它又代表着"周杰伦"这个值。然后，我们可以在这个方法体内对这个name进行其他的操作。

那我们再仔细想一想，假如GreetPeople方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值EnglishGreeting的时候它代表着EnglishGreeting()这个方法；当我们给它赋值ChineseGreeting的时候，它又代表着ChineseGreeting()的方法，我们将这个参数变量命名为MakeGreeting，那么不是可以如同给name赋值的时候一样，在调用Greet People()方法的时候，给这个MakeGreeting参数也附上值么，然后我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法是一样的，比如`MakeGreeting(name)`；

好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子：

```C#
public void GreetPeople(string name, *** MakeGreeting){
	MakeGreeting(name);
}
```

注意到 ***，这个位置通常放置的应该是参数的类型，但是到目前为止，我们仅仅想到的是应该有一个方法，并且按照这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？

**说明：**这里已经不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是EnglishGreeting，而在这两个方法内部，已经对使用GroodMoring还是早上好做了区分。

下面就该委托出场了：

我们MakeGreeting代表的两个方法的签名如下：

```C#
public void EnglishGreeting(string name);
public void chineseGreeting(string name);
```

如同`name`可以接受string类型的数据一样，MakeGreeting它也代表着接受相同的一类数据，再进一步讲，就是MakeGreeting代表了参数类型和返回类型都相同的一类方法。本例中委托的定义如下：

```C#
public delegate void GreetingDelegate(string name);
```

与上面EnglishGreeting()方法的签名对比一下，出了加入delegate关键字以外，其他的部分都是完全一样的，那么再次调用GreetPeople方法，如下所示：

```C#
public delegate void Greetingdelegate(string name);
public void GreetPeople(string name, Greetingdelegate MakeGreeting){
	MakeGreeting(name);
}
```

委托Greeting Delegat出现的位置和string相同，string是一个类型，Greeting Delegate也是一个类型，或者说是一个类。但是委托的声明方式和类完全不同。实际上，委托在编译的时候确实会被编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。下面是一个完整的代码。

```C#
public delegate void GreetingDelegate(string name);
 
class Program
{
    private static void EnglishGreeting(string name)
    {
        Console.WriteLine("Good Morning, " + name);
    }
 
    private static void ChineseGreeting(string name)
    {
        Console.WriteLine("早上好, " + name);
    }
 
    private static void GreetPeople(string name, GreetingDelegate MakeGreeting)
    {
        MakeGreeting(name);
    }
 
    static void Main(string[] args)
    {
        GreetPeople("Joe", EnglishGreeting);
        GreetPeople("周杰伦", ChineseGreeting);
        Console.ReadLine();
    }
}
```

结合游戏开发中的实际应用，我们经常讲委托和单例模式、观察者模式等设计模式结合在一起使用，下面我将尝试抽象出一个事件中心的类，它专门负责处理各种委托事件，由于在一个游戏进程中只会有一个事件处理中心，所以我要讲它设计成[单例模式](#Singleton)。



我们现在对委托做一个总结：委托是一个类，它定义了方法的类型，使得可以将方法作为另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量地使用if-else(switch)语句，同时使得程序具有更好的可扩展性。

## 声明委托

委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。

假设有一个委托：

```C#
public delegate int MyDelegate(string s);
```

上面的委托可被用于引用任何一个带有一个单一的string参数的方法，并返回一个int 类型的变量。

声明委托的语法如下：

```C#
delegate <return type><delegate-name><parameter list>
```

## 实例化委托

一旦声明了委托类型，委托对象就必须使用new关键字来创建，并且与一个特定的方法有关，当委托创建时，传递到new语句的参数就像方法调用一样书写，但是不带有参数：

```C#
public delegate void printString(string s);
pringString ps1 = new printString(WriteToScreen);
printString ps2 = new printString(WriteToFile);
```

下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整形参数的方法，并返回一个整型值。

```C#
using System;
using System.Diagnostics;

delegate int NumberChanger(int n);

namespace DelegateAppl
{
    class TestDelegate
    {
        private static int num = 10;

        public static int AddNum(int p)
        {
            num += p;
            return num;
        }

        public static int MultNum(int q)
        {
            num *= q;
            return num;
        }

        public static int getNum()
        {
            return num;
        }

        static void Main(string[] args)
        {
            NumberChanger nc1 = new NumberChanger(AddNum);
            NumberChanger nc2 = new NumberChanger(MultNum);
            nc1(25);
            Console.WriteLine("Value of Num: {0}", getNum());
            nc2(5);
            Console.WriteLine("Value of Num: {0}", getNum());
            Console.ReadKey();
        }
    }
}
```

当上面代码被编译和执行的时候，它会产生如下结果：

```
Value of Num: 35
Value of Num: 175
```

## 委托的多播(Multicasting of a Delegate)

委托对象可以使用"+"运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可以被合并。"-"运算符可用于从合并的委托中移除组件委托。

使用委托的这个特点，我们可以创建一个委托被调用时要调用的方法的调用列表，这种行为被称为委托的多播(multicasting)，也叫组播。下面的程序演示了委托的多播：

```C#
using System;

delegate int NumberChanger(int n);

namespace DelegateAppl
{
    class testdelegate
    {
        private static int num = 10;

        public static int AddNum(int p)
        {
            num += p;
            return num;
        }

        public static int MultNum(int q)
        {
            num *= q;
            return num;
        }

        public static int getNum()
        {
            return num;
        }

        static void Main(string[] args)
        {
            NumberChanger nc;
            NumberChanger nc1 = new NumberChanger(AddNum);
            NumberChanger nc2 = new NumberChanger(MultNum);

            nc = nc1;
            nc += nc2;
            nc += AddNum;
            nc(5);
            Console.WriteLine("Value of Num: {0}", getNum());
            Console.ReadKey();
        }
    }
}
```

## 委托的用途

下面实际演示了委托的用法，委托`printString`可用于引用带有一个字符串作为输入的方法，并不返回任何东西。

我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：

```c#
using System;
using System.IO;

namespace DelegateAppl
{
    class PrintString
    {
        private static FileStream fs;
        private static StreamWriter sw;

        public delegate void printString(string s);

        public static void WriteToScreen(string str)
        {
            Console.WriteLine("The String is:{0}", str);
        }

        public static void WriteToFile(string s)
        {
            fs = new FileStream("./message.txt", FileMode.Append, FileAccess.Write);
            sw = new StreamWriter(fs);
            sw.WriteLine(s);
            sw.Flush();
            sw.Close();
            fs.Close();
        }

        public static void sendString(printString ps)
        {
            ps("Hello World");
        }

        static void Main(string[] args)
        {
            printString ps1 = new printString(WriteToScreen);
            printString ps2 = new printString(WriteToFile);
            sendString(ps1);
            sendString(ps2);
            Console.ReadKey();
        }
    }
}
```

# 事件

事件基本上说是一个用户的操作，比如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件，比如中断。

C#中使用事件机制实现线程间的通信。

## 通过事件使用委托

事件在类中声明且生成，且通过使用同一个类或者其他类中的委托与事件处理程序关联。包含事件的类用于发布事件，它被称为发布器(publisher)类。其他接受该事件的类被称为订阅器(subscriber)类。事件使用发布-订阅(publisher-subscriber)模型。

发布器(publisher)是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器类的对象调用这个事件，并通知其他的对象。

订阅器(subscriber)是一个接受事件并提供事件处理程序的对象。在发布器类中的委托调用订阅器类中

## 声明事件(Event)

在类的内部声明事件，首先必须声明该事件的委托类型。如：

```C#
public delegate void BoilerLogHandler(string status);
```

然后，声明事件本身，使用event关键字：

```C#
public event BoilerLogHandler BoilerEventLog;
```

上面的代码定义了一个名为BoilerLogHandler的委托和一个名为BoilerEventLog的事件，该事件在生成的时候会调用委托。

## 实例

```C#
using System;

namespace SimpleEvent
{
    /******发布器类*******/
    public class EventTest
    {
        private int value;

        public delegate void NumManipulationHandler();

        public event NumManipulationHandler ChangeNum;

        protected virtual void OnNumChanged()
        {
            if (ChangeNum != null)
            {
                ChangeNum(); // 事件被触发
            }
            else
            {
                Console.WriteLine("Event not fire");
                Console.ReadKey();
            }
        }


        public EventTest()
        {
            int n = 5;
            SetValue(5);
        }

        public void SetValue(int n)
        {
            if (value != n)
            {
                value = n;
                OnNumChanged();
            }
        }
    }

    /********订阅器类********/
    public class subscribEvent
    {
        public void printf()
        {
            Console.WriteLine("event fire");
            Console.ReadKey();
        }
    }


    /********触发********/
    public class MainClass
    {
        public static void Main()
        {
            EventTest e = new EventTest(); // 实例化对象，第一次没有触发事件
            subscribEvent v = new subscribEvent();
            e.ChangeNum += new EventTest.NumManipulationHandler(v.printf); // 注册
            e.SetValue(7);
            e.SetValue(11);
        }
    }
}
```





# <span id="Singleton">单例模式</span>

单例模式的官方定义是：确保一个类只有一个实例，并提供一个全局的访问点。

这里涉及到一个类的实例创建时机的问题。

在之前的学习中其实一直没有太理解static的含义，这与我不太理解一个program和运行起来的有很大的关系，我一直以为Main函数是最开始的入口，

## C#中static关键字的解释

### 静态类

1. 只能包含静态成员（静态方法或者静态变量），非静态成员是不能使用的，而非静态类可以包含静态的方法、字段、属性或者事件，并且无论对这个非静态类创建多少个实例，它的静态成员都只有一个。
2. 不能对其实例化。
3. 不能被继承，因为静态类本质上是一个抽象密封类。
4. 不能包含实例构造函数。

### 静态变量

1. static只能修饰成员变量，不能修饰局部变量。
2. 表示每次重新使用该变量所在的方法、类或者自定义类时，变量的值为程序这次运行最后一次为变量赋值时的值。
3. 静态变量一直记录变量的值，一直到下次赋值的时候。
4. 不同线程下访问的静态属性总是同一属性，如果某一线程更改了属性值，将造成其他线程访问属性值的错误。因此方法中访问同一静态属性就要使用`lock`关键字，或者创建互斥对象来保持静态属性在同一时间只能被某一对象的属性或方法访问。
5. 静态成员只被创建一次，所以静态成员只有一份，而实例成员有多少个对象，就有多少个成员。

### 静态方法

1. 在方法前使用static修饰，表示此方法为所在类或所在自定义所有，而不是这个类的实例所有。
2. 在静态方法中只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。
3. 每一个线程在同一时间访问的静态方法都是不同的，因此静态方法在多线程调用中不会产生冲突。
4. 在静态方法中不能直接调用实例成员，因为静态方法被调用的时候，对象还有可能不存在，
5. this/base关键字在静态方法中不能使用，因为有可能对象还不存在。
6. 静态方法只能被重载，不能被重写，因为静态方法不属于类的实例成员

### 静态构造函数

1. 静态类可以有静态构造函数，静态构造函数不可以被继承。
2. 静态构造函数用于初始化任何静态的数据，或执行仅需执行一次的特定操作，将在创建第一个实例或者引用任何静态成员之前自动调用静态构造函数。
3. 可以用于静态类，也可以用于非静态类。
4. 无访问修饰符、无参数，zhiyouyigestatic标志。
5. 不可以直接被调用，当创建类实例或引用任何静态成员之前，静态构造函数被自动执行，并且只执行一次。

什么时候适合用static？

1. 当变量需要被共享时可以将变量定义为静态变量。
2. 当方法需要被反复调用时可以将方法定义为静态方法。
3. 当一个类中包含的成员都是静态时可以将类定义为静态类。

**补充：**静态成员和静态方法是一样的，它们不属于某一个实例化的对象，而是属于这个类本身的。如果实例化的类想要调用或者访问类中的静态成员或方法可以声明一个非静态的方法，并在该方法中调用静态方法或者返回静态成员，来实现实例化的对象对静态成员和静态方法的调用。

**疑问：**为什么静态成员和方法不能使用`.`运算符访问到呢？

**答：**静态方法和静态数据成员一样，是类的一部分，不是对象的一部分，静态成员和方法对实例化的对象是没有任何意义的，因为静态方法中不能调用非静态的成员，也就影响不到实例化对象的成员和方法，感觉还是说的不太明白，慢慢理解吧。

下面我们再说一下静态成员、方法、类被创建出来的时机。





说到单例模式，单例模式中又有懒汉模式和饿汉模式

- 懒汉模式：一开始不会实例化，什么时候用就什么时候new
- 饿汉模式：一开始类加载的时候就已经实例化，并创建单例对象，以后只管用

懒汉代码实现：

```C#
public class Singleton{
	private static Singleton instance = null;
	private Singleton(){
	
	}
	public static synchronized Singleton getInstance(){
		if(instance == null){
			instance = new Singleton();
		}
		return instance;
	}
}
```

懒汉代码实现：

```C#
public class Singleton{
	private static Singleton instance = new singleton();
	private Singleton(){
	
	}
	public static Singleton getInstance(){
		return instance;
	}
}
```

饿汉与懒汉的安全和性能区别：

1. 线程安全，饿汉在线程还没出现之前就已经实例化了，所以饿汉一定是线程安全的，懒汉是在使用时才回去new实例的，new是一个动态的过程，是放到方法中实现的。如果这个时候有多个线程访问这个实例，这个时候实例还不存在，还在new，就会进入到方法中，有多少线程就会new出多少实例。一个方法只能return一个实例，那最终return出哪个呢？
