---
title: 反射委托和事件
tags:
  - C#
categories: 学习笔记
abbrlink: cd96d12
date: 2023-03-17 15:48:00
cover: "http://soincredible777.com.cn:90/25.png"
description:
swiper_index:
sticky:
---

# 重写、重载、多态的区别

重写 `override` 重载 `overload` 多态`polymorphism`

重写`override`指的是重写了一个方法来实现不同的功能，一般是用于子类在继承父类的时候后，重写父类中的方法，重写的规则：

1. 重写方法的参数列表必须完全与被重写方法的参数列表相同，否则就不能称之为重写而是重载
2. 重写方法的访问修饰符一定要大于被重写方法的访问修饰符public > protected > default > private
3. 重写的方法的返回值必须和被重写方法的返回值一致
4. 重写的方法所抛出的异常必须和被重写方法所抛出的异常一致，或者是其子类
5. 被重写的方法不能是private，否则在其子类中只是新定义了一个方法，并没有对其进行重写
6. 静态方法不能被重写为非静态方法
7. 静态方法属于类，不能被重写，因此也不能多态

重载`overload`一般用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同

重载的规则：

1. 在使用重载时只能通过相同的方法名、不同的参数形式实现。可以是不同的参数个数，不同的参数顺序（参数类型必须不一样）
2. 不能通过访问权限、返回类型、抛出的异常进行重载
3. 方法的异常类型和数目不会对重载造成影响

多态`polymorphism`可以是静态的或动态的，在静态多态性中，函数的响应是在编译的时候发生的。在动态多态性中，函数的响应是在运行时发生的。

静态多态：在编译阶段，函数和对象的连接机制被称为早起绑定，也被称为静态绑定。C#提供了两种技术来实现静态多态性：函数重载和运算符重载

动态多态的三个条件：

1. 继承
2. 重写（重写父类继承的方法）
3. 父类引用指向子类的对象（这个在[IEnumerator和IEnumerable的理解与辨析](http://soincredible777.com.cn/posts/133a9667/)这篇博客末尾提到了，当时还不太明确这是实现多态的一个条件），语句在堆内存中开辟了子类的对象，并把栈内存中的父类的引用指向了这个子类的对象

## 函数重载实例

我们可以在同一个范围内对相同的函数名有多个定义，函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。**不能重载只有返回类型不同的函数声明**

```C#
namespace LearnOverload
{
    public class Overload
    {
        public static int Add(int a, int b, int c)
        {
            return a + b + c;
        }

        public static int Add(int a, int b)
        {
            return a + b;
        }
      
      	public static float Add(float a, float b)
        {
            return a + b;
        }

        static void Main(string[] args)
        {
            int a = 1;
            int b = 1;
            int c = 1;
            Console.WriteLine(Overload.Add(a, b));
            Console.WriteLine(Overload.Add(a, b, c));
        }
    }
}
```



## 动态多态：

C#允许我们使用关键字`abstract`创建抽象类，用于提供接口部分类的实现。当一个派生类继承自该抽象类时，实现即完成。抽象类包含抽象方法，抽象方法可以被派生类实现，派生类具有更专业的功能，我们在使用抽象类的时候要注意以下几点：

- 我们不能创建一个抽象类的实例
- 我们不能在一个抽象类外部声明一个抽象方法
- 通过在类定义前面放置关键字`sealed`，可以将类声明为密封类。当一个类被声明为`sealed`时，它不能被继承。抽象类不能被声明为`sealed`

```C#
namespace PolymorhismApplication
{
    public abstract class Shape
    {
        public abstract int Area();
    }

    class Rectangle : Shape
    {
        private int _length;
        private int _width;

        public Rectangle(int a, int b)
        {
            _length = a;
            _width = b;
        }

        public int Length
        {
            set { _length = value; }
            get { return _length; }
        }

        public int Width
        {
            set { _width = value; }
            get { return _width; }
        }


        public override int Area()
        {
            return _length * _width;
        }
    }

    class RectangleTest
    {
        static void Main(string[] args)
        {
            Rectangle r = new Rectangle(2, 3);
            Console.WriteLine(r.Area());
            Console.ReadKey();
        }
    }
}
```

下面使用了虚方法来实现多态

```C#
namespace PolymorhismApplication
{
    public class Shape
    {
        public virtual int? Area()
        {
            Console.WriteLine("执行了绘制图形的基类");
            return null;
        }
    }

    class Rectangle : Shape
    {
        private int _length;
        private int _width;

        public Rectangle(int a, int b)
        {
            _length = a;
            _width = b;
        }

        public int Length
        {
            set { _length = value; }
            get { return _length; }
        }

        public int Width
        {
            set { _width = value; }
            get { return _width; }
        }


        public override int? Area()
        {
            Console.WriteLine("执行绘制矩形的函数");
            return _length * _width;
        }
    }


    class Circle : Shape
    {
        private int _radius;


        public int Radius
        {
            set { _radius = value; }
            get { return _radius; }
        }


        public Circle(int radius)
        {
            _radius = radius;
        }

        public override int? Area()
        {
            Console.WriteLine("执行Circle类的绘制函数");
            return null;
            return base.Area();
        }
    }

    class Test
    {
        static void Main(string[] args)
        {
            var shapes = new List<Shape>
            {
                new Rectangle(2, 3),
                new Circle(2)
            };

            foreach (var p in shapes)
            {
                p.Area();
            }

            Console.ReadKey();
        }
    }
}
```

联想：在写枚举器那一篇博客的时候，我们自己写枚举器的目的是为了枚举自己自定义的数据类型，而C#中是有List这个数据类型的，我们可以把我们自定义的数据类型放在List里，不也能实现枚举的效果么，那我们自己写枚举器的意义何在呢？

```C#
using System.Collections;

namespace learnIEnumerator
{
    public class Person
    {
        public string Name { set; get; }

        public Person(string name)
        {
            Name = name;
        }

        public void ShowName()
        {
            Console.WriteLine(Name);
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            var ll = new List<Person>
                {
                    new Person("李磊"),
                    new Person("王刚"),
                    new Person("彤彤"),
                    new Person("丹丹"),
                }
                ;
            foreach (Person p in ll)
            {
                Console.WriteLine(p.Name);
            }
        }
    }
}
```

写了这么多还没到本文的正题，要补的地方实在太多了。。。。。

本周要把反射、委托、事件的基本概念搞清楚，还要多少看一下项目开始游戏弹窗的实现逻辑。。。。

# 反射

反射指程序可以访问、检测和修改它本身状态和行为的一种能力。程序集包含模块，而模块包含类型，类型又包含成员。反射提供了封装程序集、模块和类型的对象。我们可以使用反射动态地创建类型的实例，将类型绑定到现有对象上，或者从现有对象中获取类型。然后可以调用类型的方法或者访问其字段和属性。

## 优缺点
