---
title: 迷思——哪有什么岁月静好,都是有人替你负重前行
abbrlink: 4d82216e
date: 2025-08-21 01:36:58
tags:
categories: 迷思
cover:
description:
swiper_index:
sticky:
---

# 当你在享受某种设计模式带给你的便利时, 你应该思考设计模式是如何给你带来便利的

起因是, 笔者想要在Unity中实现一些基于UGUI的拖拽效果, 于是开始去思考UGUI是如何实现响应输入的, 接着了解到Unity的EventSystem和一系列EventHandler接口(IPointerClickHandler、 IDragHandler等)来驱动整个System的运转. 笔者在这篇博客中并非是要讨论EventSystem的具体实现. 而是想陈述自己对EventHandler这些接口在UGUI体系中扮演角色的一些迷思. 作为UGUI的使用者, 我只关心如何实现自己想要的功能. 如果我想让一个UI元素可以响应点击, 那我就要创建一个继承自MonoBehaviour的脚本, 挂载到这个UI元素上, 再实现IPointerClickHandler接口, ok, 到此我就已经让这个UI元素可点击了, 我下面只需要专注于开发这个UI元素被点击后会发生什么就好了. 至于这背后究竟是怎样运转的, 答案在UGUI的EventSystem源码中, 但我可以不关心. 

我将上面的表述再进行一下抽象: **使用者**只负责接口行为的定义, **使用者**并不关心接口如何被调用. 

由于我经常以**使用者**的身份在写代码, 也没有阅读过诸如EventSystem的源码, 导致我的**设计思维**十分薄弱. 也就是说, 当我要做类似EventSystem类型的开发时, 我既要将自己代入**使用者**的视角, 也要代入**设计者**的视角, 此时我不再是享受岁月静好的人, 我就是那个负重前行的人. 我开始意识到阅读源码的重要性, 粗略阅读过UGUI的源码后, 我对于框架要实现的效果有了一个模糊的概念: **框架外部定义行为, 框架内部控制流程**. Unity协程、C#的Task也能套用这句话, 这两者都可以用来处理异步任务, 我无需关心它们的内部流程, 我只专注于我要处理的异步任务本身就可以. 笔者在阅读UGUI代码时反复体验到恍然大悟的感觉, 希望之后能分出精力搞清楚协程和Task的执行流程.

于是有一段时间我经常会遇到这种处境: 在业务的开发中发现一些类型中能抽象出一部分行为封装成接口, 但有可能这些类根本就不是同一个概念下的东西, 或者, 正是由于这种 只考考虑抽离行为 而不考虑接口调用时机和接口持有者的数据组织格式, 导致绝大部分抽离行为封装接口的操作都十分多余. 

接口的行为不止于此 我记得在刚入行的时候, 一个程序员前辈跟我说, 写代码是一个十分繁琐的过程, 但如果你觉得某一部分代码写起来好像不用那么繁琐就能实现你的功能, 那有可能是有人在你不知道的地方帮你做了很多事情. 我上面举的EventSystem就是这样一个例子, UGUI系统通过对外暴露EventHandler接口的方式, 在内部有能够持有接口实例的方法, 你不需要去关心UGUI系统内部是如何持有接口实例的. YooAsset自定义打包Step也是类似的思想, 二者都是通过某种方式持有了外部的对象实例, Unity是通过运行时持有并遍历所有的GameObject, 找到上面的EventHandler来持有它们, 而YooAsset则是在Init时将需要的buildstep实例注册到YooAsset内部去. 



# 对IMGUI和UGUI实现机制的思考

当你习惯了使用UGUI这一套东西时, 让你用IMGUI, 你会特别不舒服, 感觉用起来会很别扭. 原因是: IMGUI既要操心交互逻辑是什么, 还要在OnGUI方法里自己去写UI组件触发的检测逻辑. 而UGUI则只需要操心交互的逻辑是什么, 不需要操心如何做检测的.

但是从实现方案上看, IMGUI这套完全可以用UGUI那一套的思想, UGUI用了一套EventSystem作为 触发交互的检测逻辑放在同一个地方集中处理. UGUI使用的输入的封装是`Input`, 将Input中得到的屏幕输入信息传递给`EventSystem`, 通过Raycaster模块得到 Input中的屏幕输入位置得到射线触碰到了哪个物体`GameObject`, 然后去获取到这个物体上面所有UGUI体系中的EventHandler, 根据Input中传来的触碰信息(按下、拖拽等)去触发相关的Handler, 如果这个GameObject上有相关的组件的话.

IMGUI这一套的UI组件不是以组件的方式组织的, 是以`Rect`为结构组织的, `IMGUI`使用的输入的封装是`Event`, IMGUI这一套, 不是通过什么按钮组件之类的去判断的, 所有的组件都是一个Rect, 对外暴露方法, 比如Button或者Toggle, 然后在OnGUI中 就相当于Update方法, 去查询所有的Rect区域, 首先判断一下鼠标在不在这个区域里面, 如果这个区域你是作为按钮去使用的, 那么继续去看`Event`中`EventType`字段表示鼠标是不是按下了, 如果按下了, 则返回True, 那么在OnGUI的逻辑里面就拿到了返回值是true, 代表这个按钮被按下了, 就可以去执行按钮点击的逻辑了. 去判断当前鼠标的位置, 以及鼠标的状态 比如是点击、持续点击、拖拽等等, 然后直接在这个方法内, 根据数据的数据做对应的逻辑和表现. 

# 制定规范、制定设计模式的时候是最麻烦的, 就像是开发UGUI的EventSystem绝对不是什么轻松的工作, 但是确实一定程度上实现了“一劳永逸” 

## 搭建一个框架 真的很痛苦

### 严重的代码洁癖, 出现设计考虑之外的情况 容易动摇 想要推倒重做

### 搭建一个框架 普适性是个问题 不确定能否应对之后的业务场景

### 缺少耐心

## 要真的去写 才能知道是不是真的能抽象


# 对于Unity协程

注意, 理解了yield return并不能帮助你理解Unity的协程异步机制, 这里面其实有两层迷雾, 第一层, 是yield return背后代表的代码逻辑怎样的, 你可以认为, 上述笔者观点中的**行为**定义, C#也给你封装了起来, 你看不到, 第二层迷雾, 是Unity把如何调用行为的逻辑也给你隐藏了起来, 因此, 你理解了yield return背后代表的是什么代码, 只是揭开了第一层迷雾, 到这里你对于Unity协程的使用程度, 才跟你对UGUI的使用等下, 要想继续了解内部如何控制流程, 那么你就需要像阅读UGUUI的EventSystem源码一样, 去阅读UnityMonoBehaviourC++代码中, 是如何调用yield return所生成的那个IEnumerator的MoveNext的.

我觉得不管Unity叫它协程还是什么别的, 它本质就是一个迭代器, 那么我们就尝试从集合的角度去理解这个事情,

首先foreach是干什么的?
foreach是控制流程的.

UnityMonoBehaviour中干的事情就是这个, 它也在控制流程, 你可以理解为它在遍历这个迭代器所处理的集合, UnityMonoBehaviour的角色和foreach的角色等价. 只是foreach中的MoveNext的调用时机很简单, foreach是, 遍历一个元素, 处理一下, 紧接着遍历下一个, 而在MonoBehaviour中, 因为Unity初衷就是要用它来做一些延时操作. 因此MoveNext的调用是有说法的. 不是像foreach一样, 遍历一个紧接着调用MoveNext, 而是用DelayedManager做一下延时调用. 另外还要注意, 有一点挺反直觉的, 你想要让协程继续下去, MoveNext要是true. 而不是false. 应该是要在MoveNext里面修改Current的值的,

比如说C# List的源码, 

```C#
public bool MoveNext() {

    List<T> localList = list;

    if (version == localList._version && ((uint)index < (uint)localList._size)) 
    {                                                     
        current = localList._items[index];                    
        index++;
        return true;
    }
    return MoveNextRare();
}

private bool MoveNextRare()
{                
    if (version != list._version) {
        ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EnumFailedVersion);
    }

    index = list._size + 1;
    current = default(T);
    return false;                
}

public T Current {
    get {
        return current;
    }
}

Object System.Collections.IEnumerator.Current {
    get {
        if( index == 0 || index == list._size + 1) {
                ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EnumOpCantHappen);
        }
        return Current;
    }
}
```

但比如说下面这段代码, 
只要访问一次Current, 就会返回一个新的WaitForEndOfFrame对象回去. 其实这个类中没有一个真正集合的概念.

```C#
public class WXGameCaptureProcess : IEnumerator
{
    private bool shareOver;

    public object Current
    {
        get
        {
            return new WaitForEndOfFrame();
        }
    }

    public WXGameCaptureProcess(Rect captureRect, Action<string> callback)
    {
#if DDZ_WXMINIGAME
        WXCanvas.ToTempFilePath(new WXToTempFilePathParam()
        {
            x = (int)captureRect.x,
            y = (int)(Screen.height - captureRect.y - captureRect.height),
            width = (int)captureRect.width,
            height = (int)captureRect.height,
            destWidth = (int)captureRect.width,
            destHeight = (int)captureRect.height,
            success = (ret) =>
            {
                Debug.Log("Screenshot saved: " + ret.tempFilePath);
                callback?.Invoke(ret.tempFilePath);
            },
            fail = (msg) =>
            {
                callback?.Invoke(null);
            },
            complete = (msg) =>
            {
                shareOver = true;
            }
        });
#else
        callback?.Invoke("");
#endif
    }

    public bool MoveNext()
    {
        return !shareOver;
    }

    public void Reset()
    {
        shareOver = false;
    }
}
```

# 而当我们尝试梳理C#中编写的复杂yield return的时候, 我们是在梳理什么?

yield return 中嵌套yield rteurn 的含义是什么?

意思其实是, 迭代器迭代的集合里面有一个集合元素又是一个迭代器.

这样总结下来, 一共就有三种常见迭代器迭代集合的方式了, 第一种是像List那样的正统
第二种是Unity通过yield return 创建出来的
第三种是创建一个类, 继承IEnumerator. 比如WXGameCaptureProcess这个, “模拟”了一个集合




最近笔者想要给项目的换皮活动也做一个类似的, 一个活动换皮要有下面几个固定的步骤 导入资源、更新配置表, 定义一个IStep接口, 接口内有一个Action行为, 调用方可以实现多个继承IStep接口的类, 比如导入资源类、更新配置表类, 然后在Action行为中就可以实现是如何导入资源的、如何更新配置表的. 然后将导入资源类和更新配置表类再注册到一个序列化的数据结构或者硬编码的脚本中, 在执行换皮的时候就是从序列化数据或者硬编码脚本中拿到这一套流程信息 传入到 我这套换皮框架中, 外部不用管我内部是如何驱动这套流程信息运转的, 这样的模式和上面举的UGUI、YooAsset的例子大同小异.

我有段时间看了大量讲述C#Task的文章, 现在再去回想其实还是不甚理解, 多去想想

定义接口的目的, 让一些类型具有某些行为, 并且可以通过声明接口类型, 来持有接口的实例, 一个实例的对象既可以是该实例的class类型, 也可以是其实现的任意一个接口的类型.
下面列举了笔者在开发过程中遇到的

1. C#中的非托管资源在使用的时候可以实现IDisposable接口, 在Dispose接口中, 给了开发者比较统一便捷的方式对不同的非托管资源进行释放的一个点, 另外其中


3. 语法糖foreach, 有一个IEnumerable和IEnumerator, 使用IEnumerable标识一个类型的身份, 

因此 接口在设计隔离性、统一操作、标识统一身份等场景下能发挥作用. 

