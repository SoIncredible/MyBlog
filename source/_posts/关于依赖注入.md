---
title: 关于依赖注入
cover: 'https://www.notion.so/images/page-cover/webb1.jpg'
abbrlink: 978a7745
date: 2024-11-21 23:01:31
tags:
categories:
description:
swiper_index:
sticky:
---

起因是，笔者在调研如何实现一套高效的UI换皮框架的时候，接触到了依赖注入的概念。所谓UI换皮，就是在UI的交互和显示文本内容信息等功能模块不变的情况下，仅仅是需要做美术资源的替换或者动画的修改。在笔者过往的开发过程中，UI的交互模块和动效模块并没有分割。那么就导致了一个问题：当项目进入一个大量美术风格测试的阶段时，比如，有十套美术风格要上线测试，按照之前的方案，笔者就要复制十分类似的预制体，然后为这十套预制体各自编写一套控制脚本，很麻烦的一点是，页面中的按钮、文本信息都是一样的，而我需要在十份不同的脚本中编写十次，并且，当其中某一个按钮的点击功能或者文本的内容发生改变时，我就要去改十份脚本中的内容，维护成本实在是太高了，因此笔者希望找到一种解决方案，能够将UI中的功能模块与动效模块隔离开，只需要编写一次功能模块，表现模块由于动画实现方式等原因必定是要定制的。 由此，笔者了解到了`Zenject`或许可以解决我们的问题。
我们的问题在于，在不同的页面中，按钮、文本等交互组件的节点是无法保证的，每一种美术风格如何向UI的交互模块的代码中传入正确的Button或Text组件呢？这就是我们的问题

# Zenject概念

当我们在编写一个单独的类来实现某个功能的时候，它大概率需要

```
public class Foo
{
    ISomeS

}
```
# 几种注入方式

## 构造器注入

```
public class Foo{
    IBar _bar;

    public Foo(IBar bar){
        _bar = bar;
    }

}
```

## 字段注入

```
public class Foo{
    [Inject]
    IBar _bar;
}
```

字段的注入发生在构造函数调用之后。所有被标记了[Inject]特性的字段都会在容器中查找并给定一个值。无论这个字段是private还是public方法，注入都会发生

## Property Injection

```
public class Foo{
    [Inject]
    public IBar Bar{
        get;
        private set;
    }
}
```

PropertyInjection和字段的情况一样，同样的，无论setter/getter是public还是private注入都会发生

## Method Injection

```
public class Foo{
    IBar _bar;
    Qux _qux;

    [Inject]
    public void Init(IBar bar, Qux qux){
        _bar = bar;
        _qux = qux;
    }
}
```
Method Inject和构造函数注入十分相似

一些需要说明的：
- 对于继承自MonoBehaviour的脚本来说，更推荐使用Method注入的方式，因为我们无法操作MonoBehaviour的构造函数。
- 可以将任意数量的Method标记为Inject，不过这些Method被Inject的顺序是从基类到子类的。这种设计有利于避免，同时确保了基类中的方法首先完成注入，就跟构造方法的执行顺序一样。
- InjectMethod在所有其他注入类型注入完成后完成注入
- 你可以安全地假定（一种情况除外：你的代码中存在循环依赖）。
- 需要注意的是，使用注入方法来执行初始化逻辑通常不是一个好的方法。更推荐的方式是使用IInitializable.Initialize或者Start()方法，因为这样允许你首先创建整个初始对象图。

推荐 
跟字段/属性注入比起来，使用构造方法和属性注入的方式更加推荐

- 构造方法注入强迫该构造方法的依赖只在该类被创建的时候指定一次，这通常是你想要的。在大多数的情况下，你并不想暴露一个狗公的属性

# 向依赖注入容器中注册映射关系

依赖注入框架的核心就是DI container。 它最简单的形式就是一个持有所有注册项目的字典，本节我们将尝试使用，在Zenject中，这被叫做binding(绑定关系)。因为它在抽象类型和具体类型之间创建了绑定关系。

## Binding

每个依赖注入框架的最终形态就是一个将类型和实例绑定起来的框架。

在Zenject中，依赖映射通过向一个名为container(容器)的结构中添加绑定关系来完成。添加完映射关系之后，这个容器就知道了如何在你的Application中创建所有的对象实例，通过递归地解决给定物体上的所有的依赖。

当这个容器被要求用一个给定的类型构建一个实例，这个容器使用反射来找到这个类的构造方法中的参数和所有被标记了`[Inject]`特性的字段/属性。然后这个容器会尝试解决每一个需要的它用来依赖，

因此每一个Zenject application必须告诉容器如何决定每一个依赖，通过`Bind command`的方式，比如下面这个例子:
```
public class Foo
{
    IBar _bar;

    public Foo(IBar bar){
        _bar = bar;
    }

}
```

我们可以使用下面的代码来连接这个类中的依赖项：
```
Container.Bind<Foo>.AsSingle();
Container.Bind<IBar>().To<Bar>.AsSingle();
```

这告诉Zenject每一个需要类型Foo的依赖应该使用同样的实例，这个实例将会在需要的时候自动创建。类似地，任何需要IBar和接口的类将会被分配同样的Bar类型的实例。

完整的`Bind Command`形式如下。需要指明大部分的情况我们将不回用到以下所有的方法，当没有指明调用某些方法的时候，将会使用默认值
```
Container.Bind<ContractType>()
    .WithId(Identifier)
    .To<ResultType>()
    .FromConstructionMethod()
    .AsScope()
    .WithArguments(Arguments)
    .OnInstantiated(InstantiatedCallback)
    .When(Condition)
    .(Copy|Move)Into(All|Direct)SubContainers()
    .NonLazy()
    .IfNotBound();
```
下面解释一下各个Method的含义:
- ContractType: The type that you are creating a binding for.
- ResultType: The type to bind to.
- Identifier
- FromConstructionMethod
- Scope
- 
