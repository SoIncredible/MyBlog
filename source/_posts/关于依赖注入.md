---
title: 关于依赖注入
cover: 'https://www.notion.so/images/page-cover/webb1.jpg'
abbrlink: 978a7745
date: 2024-11-21 23:01:31
tags:
categories:
description:
swiper_index:
sticky:
---

起因是，笔者在调研如何实现一套高效的UI换皮框架的时候，接触到了依赖注入的概念。所谓UI换皮，就是在UI的交互和显示文本内容信息等功能模块不变的情况下，仅仅是需要做美术资源的替换或者动画的修改。在笔者过往的开发过程中，UI的交互模块和动效模块并没有分割。那么就导致了一个问题：当项目进入一个大量美术风格测试的阶段时，比如，有十套美术风格要上线测试，按照之前的方案，笔者就要复制十分类似的预制体，然后为这十套预制体各自编写一套控制脚本，很麻烦的一点是，页面中的按钮、文本信息都是一样的，而我需要在十份不同的脚本中编写十次，并且，当其中某一个按钮的点击功能或者文本的内容发生改变时，我就要去改十份脚本中的内容，维护成本实在是太高了，因此笔者希望找到一种解决方案，能够将UI中的功能模块与动效模块隔离开，只需要编写一次功能模块，表现模块由于动画实现方式等原因必定是要定制的。 由此，笔者了解到了Zenject或许可以解决我们的问题。
我们的问题在于，在不同的页面中，按钮、文本等交互组件的节点是无法保证的，每一种美术风格如何向UI的交互模块的代码中传入正确的Button或Text组件呢？这就是我们的问题


# 使用建议

- 对于继承自MonoBehaviour的脚本来说，更推荐使用Method注入的方式，因为我们无法操作MonoBehaviour的构造函数。

# 向依赖注入容器中注册映射关系

依赖注入框架的核心就是DI container。 它最简单的形式就是一个持有所有注册项目的字典，本节我们将尝试使用，在Zenject中，这被叫做binding(绑定关系)。因为它在抽象类型和具体类型之间创建了绑定关系。

## Binding

每个依赖注入框架的最终形态就是一个将类型和实例绑定起来的框架。

在Zenject中，依赖映射通过向一个名为container(容器)的结构中添加绑定关系来完成。添加完映射关系之后，这个容器就知道了如何在你的Application中创建所有的对象实例，通过递归地解决给定物体上的所有的依赖。

当这个容器被要求用一个给定的类型构建一个实例，这个容器使用反射来找到这个类的构造方法中的参数和所有被标记了`[Inject]`特性的字段/属性。然后这个容器会尝试解决每一个需要的它用来依赖，

因此每一个Zenject application必须告诉容器如何决定每一个依赖，通过`Bind command`的方式，比如下面这个例子:
```
public class Foo
{
    IBar _bar;

    public Foo(IBar bar){
        _bar = bar;
    }

}
```

我们可以使用下面的代码来连接这个类中的依赖项：
```
Container.Bind<Foo>.AsSingle();
Container.Bind<IBar>().To<Bar>.AsSingle();
```

这告诉Zenject每一个需要类型Foo的依赖应该使用同样的实例，这个实例将会在需要的时候自动创建。类似地，任何需要IBar和接口的类将会被分配同样的Bar类型的实例。

完整的`Bind Command`形式如下。需要指明大部分的情况我们将不回用到以下所有的方法，当没有指明调用某些方法的时候，将会使用默认值
```
Container.Bind<ContractType>()
    .WithId(Identifier)
    .To<ResultType>()
    .FromConstructionMethod()
    .AsScope()
    .WithArguments(Arguments)
    .OnInstantiated(InstantiatedCallback)
    .When(Condition)
    .(Copy|Move)Into(All|Direct)SubContainers()
    .NonLazy()
    .IfNotBound();
```
下面解释一下各个Method的含义:
- ContractType:
