---
title: 游戏开发中的设计模式(零) —— 准备工作
abbrlink: eb0ca922
date: 2024-09-13 00:38:54
tags:
    - 设计模式
categories:
    - 游戏开发中的设计模式
cover: https://www.notion.so/images/page-cover/met_vincent_van_gogh_oleanders.jpg
description:
swiper_index:
sticky:
---

# 场景搭建

![](游戏开发中的设计模式-零-——-准备工作/image22.png)

在开始进入正题之前，需要先搭建一个可以供角色站立、移动、跳跃并且还有边界的测试场景。笔者希望搭建的场景要遵循一些规范：
1. 统一所有模型资源的单位长度，极特殊情况，所有模型的缩放都设置为1
2. 将场景中的地形预制体化，比如墙、地面、台阶等
3. ...

下面说一个可以提高我们搭建场景效率的技巧：在Unity的Scene窗口中，点击下图位置的图标可以设置物体移动的固定步长。按住`Control/Command`键拖拽Scene中选中物体的Object坐标系的坐标轴，就可以以固定的步长移动物体了。按住`V`键拖拽坐标轴就可以让选中物体的选中顶点吸附到另一个场景中的物体上。

![](游戏开发中的设计模式-零-——-准备工作/image.png)

## 创建地形

### Unity中自带的模型

Unity中自带的用来表示平面的是`Plane`模型，用来表示墙面的是`Quad`模型，在场景中分别创建`Plane`和`Quad`模型，查看它们的详细信息，你会发现`Plane`模型的尺寸是10x10的(此处不考虑模型的厚度)，也就是长宽各为10个单位长度；而`Quad`模型的尺寸是1x1，长宽各1个单位长度。也就是说需要使用100个`Quad`模型才能拼出一个和`Plane`面积一样大的模型。

### 创建材质

为了让地形看起来不那么单调，我们使用Unity内置的一张贴图来装饰我们的地形，我们会为Plane和Quad各自生成一个材质，这两个材质的区别只有上面的Tilling参数，一个设置成10，而另一个设置为1。这样的设置主要和这两种模型的尺寸有关系。然后将材质分别赋给这两个模型。好了，这样我们就有搭建场景的预制地形了。



模型的面片和材质上Tilling的对应关系 注意场景搭建的规范 所有的模型都适用1:1的大小标准

# 创建角色移动脚本

首先我们明确一下我们要实现的是类似GTA和巫师3这样的第三人称视角的控制角色移动方式，本节只实现最简单的前后左右移动和角色转向的逻辑。

## 基本思想

游戏中，我们按下W键，角色会向前移动；按下S键，角色会先转身面对镜头，然后移动；按下A键，角色先向左转，然后移动；按下D键，角色先向右转，然后移动。我们发现，无论按下哪个键，角色都是朝着他们自己的前方移动的。但是我们在按下`WSAD`键时是希望角色向前、后、左、右移动的。这里存在一个参考系的区别，如果我们把自己代入到我们控制的角色视角上，我们确实一直都是在向前走；而在摄像机的视角中，我们控制的角色也确实按照我们的意愿朝某一方向在移动。因此我们想要向某个方向移动是一个**摄像机视角下**的概念。摄像机面向的方向是前进的方向，摄像机面向方向的左方是向左移动的方向，右边和后面分别是摄像机面向方向的右边和后边。我们要向前移动，就是要让我们控制的角色的朝着摄像机朝向的方向移动；要向左移动，就是要让角色的朝向和摄像机左方的方向移动，角色的朝向向我们移动方向重合的过程中就会造成的角色转向。

所以说，实现本节角色移动效果的关键是处理好角色的朝向和摄像机朝向的关系。

在开始写代码之前之前我们需要了解四个接口：

## Quaternion接口相关

- [Quaternion.Slerp](https://docs.unity3d.com/ScriptReference/Quaternion.Slerp.html)
  传入**我们控制角色当前在世界空间下朝向的Quaternion**、**我们希望角色移动方向的Quaternion**和一个表示转向速度的值，返回当前帧控制角色在世界空间下新的朝向Quaternion。
- [Quaternion.LookRotation](https://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html)
  传入一个世界空间坐标下的方向向量，返回该方向向量对应的Quaternion。

## RigidBody接口相关

- [Rigidbody.MoveRotation](https://docs.unity3d.com/ScriptReference/Rigidbody.MoveRotation.html)
  传入这一帧角色朝向的世界坐标下的Quaternion，更新角色的朝向。
  
- [Rigidbody.MovePosition](https://docs.unity3d.com/ScriptReference/Rigidbody.MovePosition.html)
  传入这一帧角色的世界坐标下的Position，更新角色的位置。

## transform.forward和Vector3.forward的区别

[Transform.Translate](https://docs.unity3d.com/ScriptReference/Transform.Translate.html)

transform.translate(vector3.forward * Time.deltaTime);等价于 transform.Translate(transform.forward * Time.deltaTime, Space.World);前者是在对象空间坐标下实现物体移动的方式，后者是在世界空间坐标下实现物体移动的方式，因此transform.forward是一个世界空间坐标系下的概念。

## 代码实现

我们会在代码中声明一个用来表示当前帧移动方向的字段`_moveDir`，通过判断当前帧有哪些按键被按下决定该_moveDir的值，
我们需要把这个_moveDir字段代表的是摄像机对象空间下的方向，我们需要把这个方向转换成世界空间坐标系下的向量，然后我们还知道角色的transform.forward方向，通过Quaternion.Slerp

```
using UnityEngine;

namespace PlayerMovement
{
    public class PlayerMovement : MonoBehaviour
    {
        private Camera _camera;
        private Rigidbody _rigidBody;

        [SerializeField] private float turnSpeed = 0.02f;
        [SerializeField] private float speed = 20f;

        private Vector2 _moveDirection = Vector2.zero;
        private void Awake()
        {
            _camera = GameObject.Find("Camera").GetComponent<Camera>();

            _rigidBody = GetComponent<Rigidbody>();
        }

        private void Update()
        {
            UpdateInput();
         
           UpdateMovement();
           UpdateRotation();
        }

        private void UpdateInput()
        {
            _moveDirection = Vector2.zero;
            if (Input.GetKey(KeyCode.W))
            {
                _moveDirection += Vector2.up;
            }
            
            if (Input.GetKey(KeyCode.A))
            {
                _moveDirection += Vector2.left;
            }
            
            if (Input.GetKey(KeyCode.S))
            {
                _moveDirection += Vector2.down;
            }
            
            if (Input.GetKey(KeyCode.D))
            {
                _moveDirection += Vector2.right;
            }
            
            _moveDirection.Normalize();
        }
        
        private void UpdateMovement()
        {
           var movement = CameraDirection(new Vector3(_moveDirection.x, 0, _moveDirection.y)) * speed * Time.deltaTime;
           _rigidBody.MovePosition(transform.position + movement);
        }

        private void UpdateRotation()
        {
            if(_moveDirection.magnitude <= 0.01f) return;
            var rotation = Quaternion.Slerp(_rigidBody.rotation,
                Quaternion.LookRotation (CameraDirection(new Vector3(_moveDirection.x, 0, _moveDirection.y))), turnSpeed);
            
            _rigidBody.MoveRotation(rotation);
        }

        private Vector3 CameraDirection(Vector3 dir)
        {
            var cameraForward = _camera.transform.forward;
            var cameraRight = _camera.transform.right;
            
            cameraForward.y = 0;
            cameraRight.y = 0;
            
            return cameraForward * dir.z + cameraRight * dir.x;
        }
    }
}
```

# 参考资料
- [Unity 实用教程 之 物体固定值移动调整顶点吸附](https://jingyan.baidu.com/article/1612d500968440e20e1eeebd.html)
- [Unity3d vector3.forward和transform.forward的区别！](https://blog.csdn.net/kaluluosi111/article/details/17206655?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-17206655-blog-78846299.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-17206655-blog-78846299.235%5Ev43%5Econtrol&utm_relevant_index=5)



