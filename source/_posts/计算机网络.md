---
title: 计算机网络
abbrlink: e255a10a
date: 2025-08-21 00:42:31
tags:
categories:
cover:
description:
swiper_index:
sticky:
---

[Skynet入门](https://www.bilibili.com/video/BV19d4y1678X/?vd_source=83f4165825ce9df46cf4fd576ccb1102)

# 路由器的概念

# 端口

# IP地址

# C# Socket编程

# 什么是Socket

一个Socket连接的流程
客户端发起

需要注意的是, 可以多次发起连接请求, 这样就会建立多个Socket, 存在风险

## Socket分为两种
第一种是监听Socket

第二种是会话Socket

你的理解很准确，确实**服务端会有两个不同用途的Socket对象**：

1. **监听 Socket**（称为 `listenSocket`），职责是：
   - 绑定端口，用于侦听新的连接请求（`Bind` + `Listen`）。

2. **会话 Socket**（每连一个客户端，对应一个），职责是：
   - 和某个客户端具体收发数据（`Accept` 的返回值）。

---

## 为什么要这样分开？为什么不能直接用监听socket和客户端通信？

### 一、协议/设计层面的原因

1. **监听Socket只负责接收连接请求**
   - 监听socket在TCP层维护了一个“正在监听端口、等待连接”的队列（backlog）。
   - 它不能用来真正收发数据，只能等待新连接，然后通过`Accept`产生一个新的会话socket。
   - TCP协议里，监听socket和会话socket拥有不同的状态。

2. **每个客户端要有独立的socket对象**
   - 这样服务端才能同时和多个客户端通信（每个连接一个独立文件描述符），互不干扰。
   - 如果直接用监听socket收发数据，就无法区分哪个客户端发来的数据，也无法并发处理，直接崩溃！
   - `Accept` 会为每个客户端分配一个新的 socket，底层内核分配新的资源、端点，服务端逻辑才能独立管理。

3. **多路复用、并发模型需要会话socket**
   - 服务端通常有几十万个连接，如果全部抢占同一个监听socket，相互干扰，严重影响并发性能。
   - 新的socket会与客户端唯一绑定，方便后续select/epoll/IOCP或线程池单独处理。

4. **监听socket和会话socket的状态不一样**
   - 监听socket是“LISTEN”状态，只能等待连接。
   - 接受后的会话socket进入“ESTABLISHED”状态，才能双向收发数据。

### 二、操作系统实现原因

- **Linux/Windows的内核管理：**
  - 监听socket分配backlog（等待区），只用于管理连接请求队列；
  - 收到客户端请求，内核分配一个新socket fd（会话socket），维护与对方的TCP会话状态。
  - 只有这个fd才能安全读写数据，监听socket的fd不能用来读写，只能accept。

- **安全/隔离：**
  - 监听socket本身不能被污染——收发数据万一断了会影响整个服务器socket监听。
  - 每个连接单独分配资源，有问题只会影响单个连接，容易控制和管理。

---

### 图示理解（伪代码）：

```csharp
Server Socket Life Cycle

// 1. 创建监听Socket
Socket listenSocket = new Socket(...);
// 2. 绑定端口
listenSocket.Bind(...);
// 3. 进入监听
listenSocket.Listen(...);

while (true) {
    // 4. 每有一个新连接, Accept会分配一个新的会话Socket
    Socket conn = listenSocket.Accept();
    // 5. 后续和客户端的所有收发数据，都用conn这个socket
}
```
- `listenSocket` 只负责新增连接。
- `conn` 负责和某个客户端通信。
- 有n个客户端，就有n个会话Socket，**只有一个监听Socket**。

---

## 举个实际例子

- **Web服务器（比如IIS/Apache/nginx）**
  - 监听端口80，只用监听socket握手接收新用户连接请求。
  - 每有新请求，生成一个会话socket，和该连接通信，互不干扰。
  - 如果用同一个监听socket收发数据，所有人混流，无法区别谁是谁。

---

## 小结

- **监听socket**：只负责侦听和接受新连接，不能收发数据。
- **会话socket（Accept出来的）**：和某个客户端具体通信，收发数据。
- 这样设计是操作系统/协议规定的，**能确保高效并发、安全隔离和稳定运行**。

---

> **“监听socket是连接的大门，只用来看谁想进来；会话socket是进入之后，与某个人的密室专线，对每个身份都有独立沟通渠道。只有分开，管理和性能才能做好。”**

---

如需更底层协议细节，可以补充TCP状态转移图/源码！


你的两个问题很专业，下面逐条详细说明：

---

## 1. 创建监听 Socket 和会话 Socket 的流程一样吗？

### 在 Socket 编程（比如 C#）里：

- **监听 Socket** (`listenSocket`)
  - 你得主动创建：`new Socket(...)`
  - 然后 Bind 到某端口：`.Bind(...)`
  - 然后开启侦听：`.Listen(backlog)`
- **会话 Socket** (`connSocket`)
  - **不是你主动创建的**。它是 listener 调用 `.Accept()` 时由系统自动生成、返回的对象。
  - 你不用再手动 Bind/Listen，它一出生就“已连上”，通信双方已确定（对端IP:Port 本地IP:Port等）。

### 流程总结

- 监听 Socket 需要 显式 创建-绑定-监听
- 会话 Socket 是通过监听 Socket 的 `.Accept()` 生成
- 你不需要对会话 Socket 进行 Bind/Listen（如果你再次Bind会报错）

> **流程不一样：监听Socket手动创建配置，连接Socket自动生成，只要收数据即可。**

---

## 2. 两者的数据内容构成上有什么区别？

### 监听 Socket

- 包含内容：
  - 本地端口/IP（Bind 过的地址，如 0.0.0.0:8000）
  - 一个监听队列（backlog）——new连接排队用
  - Socket类型(TCP/UDP)，协议族等
- **没有“远端”信息，也没有TCP序列号等通信状态**  
- 不能直接收发应用数据，只能收到新连接请求。

### 会话 Socket

- 包含内容：
  - 本地端口/IP（一般是监听Socket的端口）
  - **远端客户端IP/端口**  
  - 当前TCP连接状态、序列号、缓冲区等
  - 发送和接收缓冲区
  - TCP协议维护的连接控制块（TCP state machine、TCP窗口、拥塞控制等）
- 可以直接收发数据  
- 维护与唯一远端的连接状态、收发缓冲、数据包

#### 举个例子：
监听Socket的数据结构只包含“我负责管理这个端口和连接队列”；  
会话Socket的数据结构包含“我和这个客户端的连线状态、数据缓冲、包顺序等详细内容”。

### 表格对比

| 项目           | 监听Socket            | 会话Socket             |
|----------------|----------------------|------------------------|
| 本地地址/端口  | 有                   | 有                     |
| 远端地址/端口  | 无                   | 有                     |
| TCP连接状态    | LISTEN               | ESTABLISHED            |
| 连接队列       | backlog连接请求队列   | 无                     |
| 应用层数据通信 | 不行                 | 可以                   |
| 缓冲区         | 没有数据缓冲         | 有发送/接收缓冲区       |
| 唯一性         | 只一个（主动建）      | 客户端连接一个生成一个  |

---

## 结论

**创建流程：**  
- 监听Socket要先创建、bind、listen，主动准备好；会话Socket通过accept由内核自动生成（你调accept方法就有了）。

**内容区别：**  
- 监听Socket缺失“远端”数据，只管新连接请求；会话Socket则包含详细通信双方信息和全部TCP连接细节及缓冲区、序列号等。

> **监听Socket专注于“新连接排队、接收”，会话Socket专注于“具体数据传输”——角色完全不同。**

---

如果想看更底层源码（比如Linux内核的`struct sock`、`struct tcp_sock`），可以补充！


# Socket中如何判断一个连接断开?


# 一定要注意 Socket的执行不一定在主线程上, 可千万不要在非主线程上操作MonoBehaviour中的数据, 比如UI

## 客户端

Send方法返回只代表成功将数据放到发送缓存区中, 对方可能还没收到数据

## 服务端

Accept是建立连接用
Receive是接受消息用

Accept -> Receive

结合GPT 使用C#使用一个Actor模型


非常好的问题！  
我们来详细分析下：

---

## 问题重述

假设你有**一批 Socket**（比如100个连接），你要定期检测哪些“可读”，方式有两种：

1. 用 `foreach`，对每个 socket 调用 `.Poll(...)`。
2. 用 `Socket.Select(...)`，一次性把所有 socket 放进列表，检查谁可读。

**哪种开销大？为什么？性能代价在哪里？**

---

## 1. 分析 Poll（对每个Socket单独轮询）

- 你对每个 Socket 都调用一次 Poll。
- Poll 的本质：.NET 框架会为每个 socket 调用一次底层API（可能是 poll/select/epoll/kqueue，视平台而定），每个 socket 都要进入内核态、做一次查询，并等待指定超时时间。
- 100个Socket你就要进入内核态100次。
- 用户态和内核态的切换非常昂贵，尤其你每次只查单个Socket，无法利用系统批量检测优化。
- 结果，你的检测总时间 ≈ 100 次 Poll 耗时总和。大量重复系统调用，**内核态资源消耗大，性能低**。

---

## 2. 分析 Select（一次性批量查询）

- 你把所有Socket批量传给一次Select调用。
- 内部只进入内核态**一次**，内核态代码在本地 for（或者epoll也许是红黑树遍历等）判断这一批socket的状态，把可读/socket事件状况都批量告诉你的应用。
- 这样**调用一次系统接口**，拿回所有结果。
- 和Poll做100次系统调用比，Select只做一次系统调用+本地循环。

---

## 3. 结果对比

| 方案       | 内核切换次数  | 系统调用次数 | 主要瓶颈                |
|------------|--------------|-------------|-------------------------|
| 多次Poll   | N(100次)     | N(100次)    | 用户态<->内核态,多余切换|
| 一次Select | 1            | 1           | 内核批量查找更高效      |

- **开销主要在“内核切换+系统调用次数”！**
  - 多次 Poll 开销主要是：大量的系统调用 & 频繁的用户态/内核态切换。
  - Select 只需一次调用，数据结构拷贝也一次，不会反复切换内核，而且能一次性处理所有。
- 另外，Poll 如果你用长超时或阻塞方式，遍历所有socket总耗时会变得很长（等待多个socket轮流各自超时）。

---

## 4. 结论

- **Select 明显效率更高，开销更低。**
- Poll 在N多socket时几乎不可接受，只有少数socket（比如客户端）才推荐这么写。
- 在高并发服务器场景，多路复用总是推荐批量Select（或更优的epoll/IOCP/SocketAsyncEventArgs）。

---

## 总结（标准面试答案）

> _“遍历多个socket分别Poll，相比一次Select批量检测，最大的额外开销在于多次进行系统调用和用户/内核态切换。在socket数量增多时，这种切换会极大增加CPU和内核资源消耗。而Select可以一次性批量检测所有socket状态，大幅减少系统调用次数和切换负载，因此效率远高于多次Poll。”_

---

**结论：有多个socket（>10），推荐用`Select`。  
只用单个socket/客户端可偶尔用`Poll`。**

# 什么是粘包分包 为什么会有线程冲突的问题