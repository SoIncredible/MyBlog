---
title: 排序算法
date: 2025-01-29 16:34:13
tags:
categories:
cover:
description:
swiper_index:
sticky:
---

# 快速排序(Quick)

## 思想

## 代码实现


# 插入排序(Insert)

## 思想

## 代码实现

# 选择排序(Selection)

## 思想

## 代码实现

# 归并排序(Merge)

## 思想

归并排序采用分治的思想,先让局部有序,然后将多个有序的局部排序成一个更大的有序局部.

## 实现思路

1. 传入一个数组,数组长度为size
2. 分治,将数组分成size个长度为1的子数组,这些数组默认是有序的.
3. 合并,将这size个长度为1的子数组合并成$\frac{size}{2}$个长度为2的子数组.注意,如果size为奇数,就要分成$\frac{size - 1}{2}$个长度为2的子数组和一个长度为1的子数组
4. 重复第2、3步操作,直到子数组的长度变为`size`.

## 代码实现

```
#include <iostream>
#include <vector>
using namespace std;

// 1. 传入一个数组, 数组长度为size
// 2. 分治, 将数组分成size个长度为1的子数组, 这些数组默认是有序的.
// 3. 合并, 将这size个长度为1的子数组合并成$\frac{size} {2} $个长度为2的子数组.注意, 如果size为奇数, 就要分成$\frac{size - 1} {2} $个长度为2的子数组和一个长度为1的子数组
// 4. 重复第2、3步操作, 直到子数组的长度变为`size`.

void MergeSort(int *arr, int size);
void Merge(int *arr, int size, int begin, int mid, int end);

void MergeSort(int *arr, int size)
{
    for (int curSize = 1; curSize < size; curSize *= 2)
    {
        // 此处对边界值的判定
        for (int index = 0; index < size - curSize; index += 2 * curSize)
        {
            Merge(arr, size, index, index + curSize, index + 2 * curSize - 1 > size - 1 ? size - 1 : index + 2 * curSize - 1);
        }
    }
}

void Merge(int *arr, int size, int begin, int mid, int end)
{
    int *temp = new int[size];
    for (int i = 0; i < size; i++)
    {
        temp[i] = arr[i];
    }

    int index = begin;
    int left = begin;
    int right = mid;

    while (left <= mid - 1 && right <= end)
    {
        // 左边大于右边
        if (temp[left] > temp[right])
        {
            arr[index++] = temp[right++];
        }
        else // 右边大于左边
        {
            arr[index++] = temp[left++];
        }
    }

    while (left <= mid - 1)
        arr[index++] = temp[left++];
    while (right <= end)
        arr[index++] = temp[right++];

    delete[] temp;
}

int main()
{
    int arr[10] = {26, 99, 10, 77, 55, 89, 44, 32, 17, 18};
    MergeSort(arr, 10);

    for (int i = 0; i < 10; i++)
    {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

## 经过ChatGPT优化过的代码

```
#include <iostream>
#include <algorithm> // 为了使用 std::min
using namespace std;

void MergeSort(int *arr, int size);
void Merge(int *arr, int begin, int mid, int end);

void MergeSort(int *arr, int size)
{
    for (int curSize = 1; curSize < size; curSize *= 2)
    {
        for (int index = 0; index < size; index += 2 * curSize)
        {
            int mid = index + curSize; // 中间位置
            int end = std::min(index + 2 * curSize - 1, size - 1); // 右边界
            if (mid < size) // 确保中间位置在数组范围内
            {
                Merge(arr, index, mid, end);
            }
        }
    }
}

void Merge(int *arr, int begin, int mid, int end)
{
    int *temp = new int[end - begin + 1];
    for (int i = begin; i <= end; i++)
    {
        temp[i - begin] = arr[i];
    }

    int index = begin;
    int left = 0; // temp 的左半部分起始位置
    int right = mid - begin; // temp 的右半部分起始位置

    while (left < mid - begin && right < end - begin + 1)
    {
        if (temp[left] > temp[right])
        {
            arr[index++] = temp[right++];
        }
        else
        {
            arr[index++] = temp[left++];
        }
    }

    while (left < mid - begin)
        arr[index++] = temp[left++];
    while (right < end - begin + 1)
        arr[index++] = temp[right++];

    delete[] temp;
}

int main()
{
    int arr[10] = {26, 99, 10, 77, 55, 89, 44, 32, 17, 18};
    MergeSort(arr, 10);

    for (int i = 0; i < 10; i++)
    {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    return 0;
}

```