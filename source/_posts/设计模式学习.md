---
title: 设计模式学习
abbrlink: 279644bd
date: 2023-02-18 11:44:23
tags:
  - 设计模式
categories: 学习笔记
cover: "http://soincredible777.com.cn:90/21.png"
description:
---

# 单例模式

单例模式的官方定义是：确保一个类只有一个实例，并提供一个全局的访问点。

这里涉及到一个类的实例创建时机的问题。

在之前的学习中其实一直没有太理解static的含义，这与我不太理解一个program和运行起来的有很大的关系，我一直以为Main函数是最开始的入口，

## C#中static关键字的解释

### 静态类

1. 只能包含静态成员（静态方法或者静态变量），非静态成员是不能使用的，而非静态类可以包含静态的方法、字段、属性或者事件，并且无论对这个非静态类创建多少个实例，它的静态成员都只有一个。
2. 不能对其实例化。
3. 不能被继承，因为静态类本质上是一个抽象密封类。
4. 不能包含实例构造函数。
5. 静态类本质上是一群方法的集合。

### 静态变量

1. static只能修饰成员变量，不能修饰局部变量。
2. 表示每次重新使用该变量所在的方法、类或者自定义类时，变量的值为程序这次运行最后一次为变量赋值时的值。
3. 静态变量一直记录变量的值，一直到下次赋值的时候。
4. 不同线程下访问的静态属性总是同一属性，如果某一线程更改了属性值，将造成其他线程访问属性值的错误。因此方法中访问同一静态属性就要使用`lock`关键字，或者创建互斥对象来保持静态属性在同一时间只能被某一对象的属性或方法访问。
5. 静态成员只被创建一次，所以静态成员只有一份，而实例成员有多少个对象，就有多少个成员。

### 静态方法

1. 在方法前使用static修饰，表示此方法为所在类或所在自定义所有，而不是这个类的实例所有。
2. 在静态方法中只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。
3. 每一个线程在同一时间访问的静态方法都是不同的，因此静态方法在多线程调用中不会产生冲突。
4. 在静态方法中不能直接调用实例成员，因为静态方法被调用的时候，对象还有可能不存在，
5. this/base关键字在静态方法中不能使用，因为有可能对象还不存在。
6. 静态方法只能被重载，不能被重写，因为静态方法不属于类的实例成员

### 静态构造函数

1. 静态类可以有静态构造函数，静态构造函数不可以被继承。
2. 静态构造函数用于初始化任何静态的数据，或执行仅需执行一次的特定操作，将在创建第一个实例或者引用任何静态成员之前自动调用静态构造函数。
3. 可以用于静态类，也可以用于非静态类。
4. 无访问修饰符、无参数，zhiyouyigestatic标志。
5. 不可以直接被调用，当创建类实例或引用任何静态成员之前，静态构造函数被自动执行，并且只执行一次。

什么时候适合用static？

1. 当变量需要被共享时可以将变量定义为静态变量。
2. 当方法需要被反复调用时可以将方法定义为静态方法。
3. 当一个类中包含的成员都是静态时可以将类定义为静态类。

**补充：**静态成员和静态方法是一样的，它们不属于某一个实例化的对象，而是属于这个类本身的。如果实例化的类想要调用或者访问类中的静态成员或方法可以声明一个非静态的方法，并在该方法中调用静态方法或者返回静态成员，来实现实例化的对象对静态成员和静态方法的调用。

**疑问：**为什么静态成员和方法不能使用`.`运算符访问到呢？

**答：**静态方法和静态数据成员一样，是类的一部分，不是对象的一部分，静态成员和方法对实例化的对象是没有任何意义的，因为静态方法中不能调用非静态的成员，也就影响不到实例化对象的成员和方法，感觉还是说的不太明白，慢慢理解吧。

**挖坑：静态成员、方法、类被创建出来的时机。**

说到单例模式，单例模式中又有懒汉模式和饿汉模式

- 懒汉模式：一开始不会实例化，什么时候用就什么时候new
- 饿汉模式：一开始类加载的时候就已经实例化，并创建单例对象，以后只管用

懒汉代码实现：

```C#
public class Singleton{
	private static Singleton instance = null;
	private Singleton(){
	
	}
	public static synchronized Singleton getInstance(){
		if(instance == null){
			instance = new Singleton();
		}
		return instance;
	}
}
```

饿汉代码实现：

```C#
public class Singleton{
	private static Singleton instance = new singleton();
	private Singleton(){
	
	}
	public static Singleton getInstance(){
		return instance;
	}
}
```

饿汉与懒汉的安全和性能区别：

1. 线程安全，饿汉在线程还没出现之前就已经实例化了，所以饿汉一定是线程安全的，懒汉是在使用时才回去new实例的，new是一个动态的过程，是放到方法中实现的。如果这个时候有多个线程访问这个实例，这个时候实例还不存在，还在new，就会进入到方法中，有多少线程就会new出多少实例。一个方法只能return一个实例，那最终return出哪个呢？
1. 执行效率：饿汉模式没有加任何的锁，因此执行效率比较高。懒汉式一般使用都会加同步锁，效率比饿汉式差。
1. 内存使用：饿汉在一开始类加载的时候就实例化，无论使用与否，都会实例化，所以会占据内存空间，浪费内存。懒汉式什么时候用才什么时候实例化，不浪费内存。

# 迭代器模式

迭代器模式是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，同时也肯定支持遍历集合元素的操作，我们此时可以吧遍历操作也放在集合对象中，但是这样的话，集合对象就承担了太多责任了，面向对象设计原则中有一条是单一职责原则，所以我们要尽可能的去分离这些指责，使用不同的类去承担不同的职责。迭代器模式就是用迭代器类来承担遍历集合元素的职责。

## 迭代器模式的定义

