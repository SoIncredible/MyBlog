---
title: 数据结构——树
cover: 'https://www.notion.so/images/page-cover/rijksmuseum_jansz_1637.jpg'
abbrlink: 62b3cca9
date: 2024-01-17 00:18:39
tags:
categories: 数据结构与算法
description:
swiper_index:
sticky:
---
数据结构与算法相关的博客搭配
# 树
## 二叉树
### 遍历
#### 前序遍历
#### 中序遍历
#### 后序遍历
## 相关概念
最小二叉树
平衡二叉树
完全二叉树
二叉搜索树
红黑树


# 图的存储结构

## 邻接矩阵



## 邻接链表

## 比较


# 图的基本操作

增加边
增加节点

删除节点
删除边

# 遍历图中的节点

## 广度遍历BFS



## 深度遍历DFS


# Dijkstra算法

# Floyd算法


# 时间复杂度

常用时间复杂度表示`O(n)` `O(log n)` `O(n!)` `O(n^2)`

# 动态规划

## 动态规划五步

- DP数组以及下标的含义
- 递推公式
- DP数组如何初始化
- 遍历顺序(背包问题中先遍历背包还是先遍历物品?)
- 打印数组

## 入门
 
 - 爬楼梯、斐波那契
 - 背包问题
 - 打家劫舍
 - 股票问题
 - 子序列问题



```
int multiply(int A, int B) {
    return B?multiply(A<<1,B>>1)+(B&1?A:0):0;
}
```
代码功能
这段代码通过递归和位操作实现了两个整数的乘法，避免了直接使用 * 运算符。

关键点
位操作：

左移操作 A << 1 相当于 A * 2。
右移操作 B >> 1 相当于 B / 2。
按位与操作 B & 1 用于检查 B 的最低位是否为 1。
递归：

每次递归计算当前位的贡献，并将问题规模缩小一半，直到 B == 0。
时间复杂度：

每次递归将 B 减少一半，因此递归深度为 O(log B)。
每次递归的计算量为常数，因此总时间复杂度为 O(log B)。