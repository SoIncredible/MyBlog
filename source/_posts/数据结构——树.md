---
title: 数据结构——树
cover: 'https://www.notion.so/images/page-cover/rijksmuseum_jansz_1637.jpg'
abbrlink: 62b3cca9
date: 2024-01-17 00:18:39
tags:
categories: 数据结构与算法
description:
swiper_index:
sticky:
---

> 阅读本文之前建议先阅读[索引页]()

# 树的分类

- 满二叉树 节点数量 $ 2^k - 1 $
- 完全二叉树
- 搜索二叉树
- 平衡二叉搜索树
- 最小二叉树
- 决策树
- 红黑树

# 树
## 二叉树
### 遍历

- 按照遍历方式可以分为递归遍历和迭代遍历
- 按照遍历结果可以分成深度遍历和广度遍历

#### 广度优先遍历

##### 层序遍历

#### 深度优先遍历

递归方式
- 前序遍历

> 遍历顺序 中->左->右

```
template <typename T>
void BinaryTree<T>::InnerPreorderTraversalRecursion(BinaryTreeNode<T> *cur, Queue<BinaryTreeNode<T>> *queue)
{
    // 前序遍历 中->左->右
    if (cur == nullptr)
    {
        return;
    }

    // 输出cur的index
    queue->EnQueue(cur);
    // 遍历左
    InnerPreorderTraversalRecursion(cur->left, queue);
    // 遍历右
    InnerPreorderTraversalRecursion(cur->right, queue);
}

template <typename T>
void BinaryTree<T>::PreorderTraversalRecursion(Queue<BinaryTreeNode<T>> *queue)
{
    // 在使用C++时，当向一个方法请求返回一组数据结构时，最好的做法是调用这个方法，并向这个方法中传入用来存储结果的指针
    // 因为这样能确保这个指针的new和delete是成对出现的
    // 如果你在这个方法内部new了一个队列 然后返回出去 外部很有可能在完成操作后忘记对这个队列执行delete操作，这就造成内存泄漏了
    InnerPreorderTraversalRecursion(_root, queue);
}
```

##### 中序遍历

⚠️注意: 中序遍历要比前序和后序特殊 因为遍历树节点的顺序和处理树节点的顺序是不一样的

> 遍历顺序 左->中->右

```
// 中序遍历
template <typename T>
void BinaryTree<T>::InorderTraversalRecursion(Queue<BinaryTreeNode<T>> *queue)
{
    InnerInorderTraversalRecursion(_root, queue);
}
```

##### 后序遍历(迭代)

```
template <typename T>
void BinaryTree<T>::PostorderTraversalIteration(Queue<BinaryTreeNode<T>> *queue)
{
    Stack<BinaryTreeNode<T>> stack = Stack<BinaryTreeNode<T>>();

    stack.Push(_root);
    
    // 而后续遍历的顺序是左 -> 右 -> 中 需要将队列翻转一下
    while(!stack.IsEmpty()){
        BinaryTreeNode<T> *node = stack.Pop();
        queue->EnQueue(node);
        if(node->left != nullptr){
            stack.Push(node->left);
        }
        if (node->right != nullptr)
        {
            stack.Push(node->right);
        }
    }

    // 将队列反转

    queue->Reverse();

    // while(!queue->IsEmpty()){
    //     BinaryTreeNode<T> *node = queue->DeQueue();
    //     stack.Push(node);
    // }

    // while(!stack.IsEmpty()){
    //     BinaryTreeNode<T> *node = stack.Pop();
    //     queue->EnQueue(node);
    // }
}

```

> 遍历顺序 左->右->中

迭代方式
- 前序遍历
- 后序遍历
- 中序遍历 ⚠️注意: 中序遍历要比前序和后序特殊 因为遍历树节点的顺序和处理树节点的顺序是不一样的

# 时间复杂度

常用时间复杂度表示`O(n)` `O(log n)` `O(n!)` `O(n^2)`

```
int multiply(int A, int B) {
    return B?multiply(A<<1,B>>1)+(B&1?A:0):0;
}
```
代码功能
这段代码通过递归和位操作实现了两个整数的乘法，避免了直接使用 * 运算符。

关键点
位操作：

左移操作 A << 1 相当于 A * 2。
右移操作 B >> 1 相当于 B / 2。
按位与操作 B & 1 用于检查 B 的最低位是否为 1。
递归：

每次递归计算当前位的贡献，并将问题规模缩小一半，直到 B == 0。
时间复杂度：

每次递归将 B 减少一半，因此递归深度为 O(log B)。
每次递归的计算量为常数，因此总时间复杂度为 O(log B)。